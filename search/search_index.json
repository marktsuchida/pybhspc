{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#pybhspc-control-becker-hickl-spc-modules-from-python","title":"pybhspc: Control Becker &amp; Hickl SPC modules from Python","text":""},{"location":"#overview","title":"Overview","text":"<p>The pybhspc package provides Python bindings to the Becker &amp; Hickl SPCM DLL, which is the control and acquisition interface for SPC modules. (SPC moduels are PCI/PCIe boards that perform TCSPC (time-correlated single photon counting) or time-tagging.)</p> <p>Note: The author of this package is not affiliated with Becker &amp; Hickl GmbH.</p> <p>The main package <code>bh_spc</code> provides a few utility functions. The module <code>bh_spc.spcm</code> provides Python bindings to the SPCM functions and data types.</p> <p>To use the relatively direct bindings in <code>bh_spc.spcm</code>, you will need to understand the underlying SPCM DLL interface, provided and documented by BH. (I plan to add a higher-level interface that simplifies device enumeration and FIFO acquisition, but this is not yet available.)</p> <p>Access to all of the functions that are required for FIFO (time tag stream) mode acquisition on SPC boards (including with multiple boards) is provided by the <code>bh_spc.spcm</code> module. Not supported are functions that are specific to conventional (non-FIFO mode) acquisition, the DPC-230, and stream buffering (data buffering can readily be done using other Python facilities).</p> <p>Note that interpreting the time tag stream data (a seqeunce of binary records) is outside the scope of this library. It's always good to keep data acquisition and data processing/analysis code separate (even if they run concurrently in a particular application).</p>"},{"location":"#status-and-versioning","title":"Status and Versioning","text":"<p>This package should be considered experimental, even though the <code>spcm</code> module is reasonably complete for FIFO mode acquisition. Until version 1.0.0 is released, all APIs are subject to backward-incompatible changes. However, backward-incompatible changes will be documented following the first release (version 0.1.0).</p>"},{"location":"#hardware-requirements","title":"Hardware Requirements","text":"<p>An effort has been made to avoid making unnecessary assumptions about the SPC module type (i.e., device model). pybhspc also allows testing with the SPCM DLL set to simulation modes.</p> <p>It should be possible to operate most of the SPC boards supported by the SPCM DLL: SPC-600, 630, 130, 830, 140, 930, 150, 130EM, 150N (NX, NXX), 130EMN, 160 (X, PCIE), 180N (NX, NXX), and 130IN (INX, INXX). Recent versions of SPCM do not support some of the older models except in simulation; check the BH documentation.</p> <p>Caveat: Most of these have not been tested, especially with hardware.</p> <p>SPC-700 and 730 are not listed here because they do not have a FIFO mode.</p> <p>DPC-230 is not currently supported by pybhspc (it requires some extra functions and data types).</p> <p>SPC-QC-104 and 004 may work (no attempt has been made to test these yet, even in simulation).</p> <p>SPC-QC-008 uses a completely different programming interface and is out of scope for the pybhspc package (but BH offers a Python interface called bhpy for SPC-QC-104/004/008).</p>"},{"location":"#software-requirements","title":"Software Requirements","text":"<p>Windows 10+ (64-bit Intel).</p> <p>Python 3.10+ (64-bit).</p> <p>The Becker &amp; Hickl SPCM DLL (part of their TCSPC Package installer) must be installed on the system. The most recent version is usually recommended; absolute minimum is version 4.0 (Apr 2014; but versions below 5.1 have not been tested). Note that these are version numbers of the SPCM DLL, not of the TCSPC Package or the SPCM application.</p> <p>The SPCM DLL is automatically found at its installed location; there is no need to copy it or set any environment variables.</p>"},{"location":"#license","title":"License","text":"<p>The pybhspc package is distributed under the MIT license.</p>"},{"location":"api/","title":"bh_spc package","text":""},{"location":"api/#the-bh_spc-package","title":"The <code>bh_spc</code> package","text":"<p>The root package of pybhspc.</p> <p>For low-level control of the SPCM DLL, see the <code>spcm</code> module. Some utility functions are provided here in the root package.</p>"},{"location":"api/#bh_spc.dump_module_state","title":"<code>dump_module_state(mod_no: int, *, file=None) -&gt; None</code>","text":"<p>Print (to standard output) the status of one SPC module.</p> <p>This is a utility intended mostly for troubleshooting.</p> <p>The module must be initialized.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <code>file</code> <code>file or None</code> <p>The stream to print to.</p> <code>None</code>"},{"location":"api/#bh_spc.dump_state","title":"<code>dump_state(mod_nos: int | Sequence[int] | None = (0), *, file=None) -&gt; None</code>","text":"<p>Print (to standard output) the status SPC modules.</p> <p>This is a utility intended mostly for troubleshooting.</p> <p>The SPCM DLL must have been initialized (<code>spcm.init</code>).</p> <p>Parameters:</p> Name Type Description Default <code>mod_nos</code> <code>int or Sequence[int] or None</code> <p>The SPC module index or indices for which to dump state. If None, use all modules.</p> <code>(0)</code> <code>file</code> <code>file or None</code> <p>The stream to print to.</p> <code>None</code>"},{"location":"api/#bh_spc.ini_file","title":"<code>ini_file(text: str) -&gt; Iterator[str]</code>","text":"<p>Context manager providing a temporary .ini file with the given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The desired contents of the .ini file.</p> required <p>Yields:</p> Type Description <code>str</code> <p>The path name to the temporary .ini file.</p> See Also <p>minimal_spcm_ini     Return the text for a minimal SPCM .ini file.</p>"},{"location":"api/#bh_spc.minimal_spcm_ini","title":"<code>minimal_spcm_ini(mode: int | spcm.DLLOperationMode = 0) -&gt; str</code>","text":"<p>Return the text for a minimal .ini file for use with <code>spcm.init</code>.</p> <p>The returned .ini text only sets the <code>simulation</code> field (i.e., the DLL operation mode). For all other fields (PCI bus/card number and SPC parameters), defaults will be used.</p> <p>The return value can be saved to a file and used with <code>spcm.init</code> or as the source .ini file with <code>spcm.save_parameters_to_ini_file</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int or DLLOperationMode</code> <p>The mode in which to initialize the SPCM DLL. Use 0 for hardware; special constants for simulation.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The .ini content text.</p> See Also <p>ini_file     Context manager providing a temporary .ini file.</p>"},{"location":"api/#bh_spc.spcm_dll_version","title":"<code>spcm_dll_version() -&gt; tuple[int, int, int, int]</code>  <code>cached</code>","text":"<p>Return the file version number of the SPCM DLL.</p> <p>The information is read from the Windows version resource of the file.</p> <p>Returns:</p> Type Description <code>tuple[int]</code> <p>File version number (a 4-tuple) of the spcm64.dll file.</p>"},{"location":"api_spcm/","title":"bh_spc.spcm module","text":""},{"location":"api_spcm/#the-bh_spcspcm-module","title":"The <code>bh_spc.spcm</code> module","text":"<p>Low-level wrappers of the SPCM DLL functions and data structures.</p> <p>This extension module aims to provide straightforward Python wrappers for the C functions, structs, and enums in the SPCM DLL. Currently, only the functions required to acquire data in FIFO mode are wrapped (excluding those that are specific to the DPC-230).</p> <p>Error codes returned by functions are converted to exceptions (SPCMError). Functions that take output arguments are wrapped so that they provide the data as a return value. A few other small changes are made to facilitate usage from Python. In some cases enum names have been changed for readability.</p> <p>A design goal of this module is to generally avoid artificially restricting user code from performing operations that the C functions allow, even if they are logically questionable or lead to unexpected return values. This is so that this module can be used to experiment with the C API and discover its behavior. A higher-level interface that guides the user toward correct usage can be built on top of this module.</p> <p>As such, to fully understand the correct usage of these functions and data types, you will need to refer to the Becker &amp; Hickl SPCM DLL documentation.</p>"},{"location":"api_spcm/#bh_spc.spcm.AdjustPara","title":"<code>AdjustPara</code>","text":"<p>Adjustment parameters (wraps the <code>SPC_Adjust_Para</code> struct).</p> <p>Wraps the SPCM DLL <code>SPC_Adjust_Para</code> struct. Values of this type are returned by <code>get_adjust_parameters</code> and (as an attribute of <code>EEPData</code>) by <code>get_eeprom_data</code>.</p> <p>Instances have the attributes corresponding to the C struct fields. All are read-only.</p>"},{"location":"api_spcm/#bh_spc.spcm.AdjustPara.as_dict","title":"<code>as_dict() -&gt; dict[str, int | float]</code>  <code>method descriptor</code>","text":"<p>Return a dictionary containing the fields and values.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Every field and its value.</p>"},{"location":"api_spcm/#bh_spc.spcm.AdjustPara.items","title":"<code>items() -&gt; Iterable[tuple[str, int | float]]</code>  <code>method descriptor</code>","text":"<p>Return an iterable yielding the fields and values in fixed order.</p> <p>Returns:</p> Type Description <code>Iterable</code> <p>An iterable yielding the pair (name, value) for every field.</p>"},{"location":"api_spcm/#bh_spc.spcm.DLLOperationMode","title":"<code>DLLOperationMode</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Enum for the operation mode of the SPCM DLL.</p> <p>Values of this type are returned by <code>get_mode</code> and are given to <code>set_mode</code>.</p> <p>Not to be confused with <code>ModuleType</code>, which has similar (but slightly different) values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for e in DLLOperationMode:\n...     print(e.name, e.value)\nHARDWARE 0\nSIMULATE_SPC_600 600\n...\nSIMULATE_SPC_150NX 152\nSIMULATE_SPC_150NXX 153\n...\n</code></pre> <p>Print a table of all the enum members.</p>"},{"location":"api_spcm/#bh_spc.spcm.Data","title":"<code>Data</code>","text":"<p>The collection of values for all SPC parameters.</p> <p>Wraps the SPCM DLL <code>SPCdata</code> struct. Values of this type are returned by <code>get_parameters</code> and are passed to <code>set_parameters</code>.</p> <p>Instances have attributes that match the <code>ParID</code> enum member names, but in lowercase. Attribute types match the <code>type</code> attribute of the corresponding <code>ParID</code> enum member.</p> <p>An instance created by calling <code>Data()</code> contains zero for every parameter.</p> <p>Instances can be duplicated using <code>copy.copy()</code> (or <code>copy.deepcopy()</code>), and can also be compared with <code>==</code> for (exact) equality (see Notes below).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for p, v in Data().items():\n...     print(f\"{p} = {v}\")\ncfd_limit_low = 0.0\ncfd_limit_high = 0.0\n...\nmode = 0\n...\n</code></pre> <p>Print the values of all parameters of a default instance (more interesting if you replace <code>Data()</code> with, say, <code>get_parameters(0)</code>).</p> See Also <p>ParID : Enum of SPC parameter ids.</p> Notes <p>The C struct fields <code>base_adr</code>, <code>init</code>, <code>pci_card_no</code>, and <code>test_eep</code> are hidden from this Python wrapper. These fields are either not currently meaningful or are redundant with information that can be obtained from <code>get_module_info</code> or <code>get_eeprom_data</code>. However, these fields are included in the equality comparison, so an instance created as <code>Data()</code> may never compare equal to an instance returned by <code>get_parameters</code> even if all attributes are set to be equal. Usually it is best to avoid creating an instance from scratch except in special situations such as testing. Always obtain an instance from <code>get_parameters</code>.</p>"},{"location":"api_spcm/#bh_spc.spcm.Data.as_dict","title":"<code>as_dict() -&gt; dict[str, int | float]</code>  <code>method descriptor</code>","text":"<p>Return a dictionary containing the fields and values.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Every field and its value.</p>"},{"location":"api_spcm/#bh_spc.spcm.Data.diff_as_dict","title":"<code>diff_as_dict(other: Data) -&gt; dict[str, int | float]</code>  <code>method descriptor</code>","text":"<p>Return a dictionary containing the fields and their values where they differ from the given other instance.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Data</code> <p>The instance to compare to.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Every field that differs from <code>other</code> and its value in this instance where the value differs from the other instance.</p>"},{"location":"api_spcm/#bh_spc.spcm.Data.diff_items","title":"<code>diff_items(other: Data) -&gt; Iterable[tuple[str, int | float]]</code>  <code>method descriptor</code>","text":"<p>Return an iterable yielding the fields and values where they differ from the given other instance, in fixed order.</p> <p>The order matches with the <code>ParID</code> enum members.</p> <p>Returns:</p> Type Description <code>Iterable</code> <p>An iterable yielding the pair (name, value) for every field in this instance where the value differs from the other instance.</p>"},{"location":"api_spcm/#bh_spc.spcm.Data.items","title":"<code>items() -&gt; Iterable[tuple[str, int | float]]</code>  <code>method descriptor</code>","text":"<p>Return an iterable yielding the fields and values in fixed order.</p> <p>The order matches with the <code>ParID</code> enum members.</p> <p>Returns:</p> Type Description <code>Iterable</code> <p>An iterable yielding the pair (name, value) for every field.</p>"},{"location":"api_spcm/#bh_spc.spcm.EEPData","title":"<code>EEPData</code>","text":"<p>Information read from an SPC modules non-volatile memory.</p> <p>Wraps the SPCM DLL <code>SPC_EEP_Data</code> struct. Values of this type are returned by <code>get_eeprom_data</code>.</p> <p>Attributes:</p> Name Type Description <code>module_type</code> <code>str</code> <p>The module type as a string, such as <code>\"SPC-180NX\"</code> (read-only).</p> <code>serial_no</code> <code>str</code> <p>The serial number (read-only).</p> <code>date</code> <code>str</code> <p>Production date, such as <code>\"2024-03-26\"</code> (read-only).</p> <code>adj_para</code> <code>AdjustPara</code> <p>Adjustment parameters (read-only).</p>"},{"location":"api_spcm/#bh_spc.spcm.EEPData.as_dict","title":"<code>as_dict() -&gt; dict[str, Any]</code>  <code>method descriptor</code>","text":"<p>Return a dictionary containing the fields and values.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Every field and its value.</p>"},{"location":"api_spcm/#bh_spc.spcm.EEPData.items","title":"<code>items() -&gt; Iterable[tuple[str, Any]]</code>  <code>method descriptor</code>","text":"<p>Return an iterable yielding the fields and values in fixed order.</p> <p>Returns:</p> Type Description <code>Iterable</code> <p>An iterable yielding the pair (name, value) for every field.</p>"},{"location":"api_spcm/#bh_spc.spcm.ErrorEnum","title":"<code>ErrorEnum</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Enum of SPCM DLL error codes.</p> <p>The members' values are the SPCM DLL error codes (except for <code>UNKNOWN</code>). An additional member, <code>UNKNOWN</code>, which does not appear in the SPCM DLL, is used for any unknown error code that is encountered.</p> <p>Usually you will get a value of this type from the <code>enum</code> attribute of an <code>SPCMError</code> exception.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for e in ErrorEnum:\n...     print(e.value, e.name, get_error_string(e))\n0 NONE No error\n-1 OPEN_FILE Can't open file\n...\n-32769 UNKNOWN Unknown SPCM error\n</code></pre> <p>Print a list of all enum members and the corresponding error message.</p> See Also <p>SPCMError : Exception class for SPCM DLL errors.</p>"},{"location":"api_spcm/#bh_spc.spcm.FIFOInitVars","title":"<code>FIFOInitVars</code>","text":"<p>Dataclass aggregating the return values of <code>get_fifo_init_vars</code>.</p> <p>Attributes:</p> Name Type Description <code>fifo_type</code> <code>FIFOType</code> <p>FIFO data format.</p> <code>stream_type</code> <code>StreamType</code> <p>Stream properties.</p> <code>mt_clock</code> <code>int</code> <p>Macrotime clock units in units of 0.1 ns (or 1 fs in the case of DPC-230).</p> <code>spc_header</code> <code>array</code> <p>4-byte .spc file header. In the case of SPC-600/630 FIFO-48 format, two zero bytes should be appended to form the 6-byte file header.</p>"},{"location":"api_spcm/#bh_spc.spcm.FIFOType","title":"<code>FIFOType</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Enum of FIFO data formats.</p> <p>Values of this type are returned by <code>get_fifo_init_vars</code> as an attribute of <code>FIFOInitVars</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for e in FIFOType:\n...     print(e.name, e.value)\nSPC_600_48BIT 2\nSPC_600_32BIT 3\nSPC_130 4\nSPC_830 5\nSPC_140 6\nSPC_150 7\nDPC_230 8\nIMAGE 9\nTDC 11\nTDC_ABS 12\nUNKNOWN 0\n</code></pre> <p>Print a table of all enum members.</p>"},{"location":"api_spcm/#bh_spc.spcm.InUseStatus","title":"<code>InUseStatus</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Enum representing whether an SPC module is in use.</p> <p>Possible values are <code>NOT_IN_USE</code> (0), <code>IN_USE_HERE</code> (1), and <code>IN_USE_ELSEWHERE</code> (-1), \"elsewhere\" meaning by another program or process.</p> <p>Values of this type are returned (as an attribute of <code>ModInfo</code>) by <code>get_module_info</code>.</p>"},{"location":"api_spcm/#bh_spc.spcm.InitStatus","title":"<code>InitStatus</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Enum for the initialization status of an SPC module.</p> <p>Values of this type are returned by <code>get_init_status</code> and (as an attribute of <code>ModInfo</code>) by <code>get_module_info</code>.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>Human-readable message string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for e in InitStatus:\n...     print(e.name, e.value, e.message)\nOK 0 Initialized\nNOT_DONE -1 Initialization not requested\n...\nXILINX_ERR -100 FPGA configuration error\n</code></pre> <p>Print a table of all the enum members and corresponding messages.</p> Notes <p>The member <code>XILINX_ERR</code> is used for all possible Xilinx (FPGA configuration) errors (-100 through -199) returned by SPCM DLL functions.</p>"},{"location":"api_spcm/#bh_spc.spcm.MeasurementState","title":"<code>MeasurementState</code>","text":"<p>             Bases: <code>enum.Flag</code></p> <p>Flag enum for measurement state.</p> <p>Values of this type are returned by <code>test_state</code>.</p> <p>For the sake of readability, the enum members are named differently from the SPCM DLL. See the example below for how to view the correspondence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for n in MeasurementState.__members__:\n...     e = MeasurementState[n]\n...     print(e.name, e.value)\nSTOPPED_ON_OVERFLOW 1\nOVERFLOW 2\n...\n</code></pre> <p>Print a table of all enum members, including aliases.</p> <pre><code>&gt;&gt;&gt; for name in MeasurementState.__members__:\n...     e = MeasurementState[name]\n...     print(\n...         f\"{measurement_state_bh_name(name):16} {e.value: 6} {name}\"\n...     )\nSPC_OVERFL            1 STOPPED_ON_OVERFLOW\nSPC_OVERFLOW          2 OVERFLOW\nSPC_TIME_OVER         4 STOPPED_ON_COLLECT_TIME\nSPC_COLTIM_OVER       8 COLLECT_TIME_ELAPSED\nSPC_CMD_STOP         16 STOPPED_ON_COMMAND\nSPC_REPTIM_OVER      32 REPEAT_TIME_ELAPSED\nSPC_ARMED           128 ARMED\nSPC_COLTIM_2OVER    256 COLLECT_TIME_ELAPSED_2ND_TIME\nSPC_REPTIM_2OVER    512 REPEAT_TIME_ELAPSED_2ND_TIME\nSPC_FOVFL          1024 FIFO_OVERFLOW\nSPC_FEMPTY         2048 FIFO_EMPTY\nSPC_WAIT_FR        8192 WAITING_FOR_FRAME\nSPC_MEASURE          64 MEASUREMENT_ACTIVE\nSPC_SCRDY          1024 SCAN_READY\nSPC_FBRDY          2048 SCAN_FLOWBACK_READY\nSPC_WAIT_TRG       4096 WAITING_FOR_TRIGGER\nSPC_HFILL_NRDY    32768 HARDWARE_FILL_NOT_READY\nSPC_SEQ_STOP      16384 STOPPED_BY_SEQUENCER\nSPC_SEQ_GAP150     8192 SEQUENCER_GAP_150\nSPC_SEQ_GAP          64 SEQUENCER_GAP\nSPC_ARMED1          128 TDC1_ARMED\nSPC_CTIM_OVER1        8 TDC1_COLLECT_TIME_ELAPSED\nSPC_FEMPTY1         256 TDC1_FIFO_EMPTY\nSPC_FOVFL1         1024 TDC1_FIFO_OVERFLOW\nSPC_ARMED2        16384 TDC2_ARMED\nSPC_CTIM_OVER2       32 TDC2_COLLECT_TIME_ELAPSED\nSPC_FEMPTY2         512 TDC2_FIFO_EMPTY\nSPC_FOVFL2         2048 TDC2_FIFO_OVERFLOW\n</code></pre> <p>Print the correspondence from SPCM DLL names to pybhspc names.</p> See Also <p>measurement_state_bh_name</p>"},{"location":"api_spcm/#bh_spc.spcm.ModInfo","title":"<code>ModInfo</code>","text":"<p>SPC module information.</p> <p>Wraps the SPCM DLL <code>SPCModInfo</code> struct. Values of this type are returned by <code>get_module_info</code>.</p> <p>Attributes:</p> Name Type Description <code>module_type</code> <code>ModuleType</code> <p>The module type (read-only).</p> <code>bus_number</code> <code>int</code> <p>The PCI bus number (read-only).</p> <code>slot_number</code> <code>int</code> <p>The PCI slot number (read-only).</p> <code>in_use</code> <code>InUseStatus</code> <p>Whether the module is in use (read-only).</p> <code>init</code> <code>InitStatus</code> <p>Whether the module is initialized, and the reason why if not (read-only).</p>"},{"location":"api_spcm/#bh_spc.spcm.ModInfo.as_dict","title":"<code>as_dict() -&gt; dict[str, Any]</code>  <code>method descriptor</code>","text":"<p>Return a dictionary containing the fields and values.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Every field and its value.</p>"},{"location":"api_spcm/#bh_spc.spcm.ModInfo.items","title":"<code>items() -&gt; Iterable[tuple[str, Any]]</code>  <code>method descriptor</code>","text":"<p>Return an iterable yielding the fields and values in fixed order.</p> <p>Returns:</p> Type Description <code>Iterable</code> <p>An iterable yielding the pair (name, value) for every field.</p>"},{"location":"api_spcm/#bh_spc.spcm.ModuleType","title":"<code>ModuleType</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Enum for the module type (model number) of an SPC module.</p> <p>Values of this type are returned by <code>test_id</code> and (as an attribute of <code>ModInfo</code>) by <code>get_module_info</code>.</p> <p>Not to be confused with <code>DLLOperationMode</code>, which has similar (but slightly different) values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for e in ModuleType:\n...     print(e.name, e.value)\nSPC_600 600\nSPC_630 630\n...\nSPC_150NX_OR_150NXX 152\n...\n</code></pre> <p>Print a table of all the enum members.</p>"},{"location":"api_spcm/#bh_spc.spcm.ParID","title":"<code>ParID</code>","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Enum of SPC parameter ids.</p> <p>The members' values are the SPCM DLL parameter ids. Members also have an attribute <code>type</code> which is either <code>int</code> or <code>float</code>.</p> <p>Values of this type are passed to <code>get_parameter</code> and <code>set_parameter</code>. The attributes of the <code>Data</code> class match the lowercased version of the enum member names.</p> <p>C language parameter types <code>short</code>, <code>unsigned short</code>, and <code>unsigned long</code> all map to Python <code>int</code>. C language <code>float</code> maps to Python <code>float</code>.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>type</code> <p>The parameter type: <code>int</code> or <code>float</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for e in ParID:\n...     print(e.value, e.name, e.type.__name__)\n0 CFD_LIMIT_LOW float\n1 CFD_LIMIT_HIGH float\n...\n27 MODE int\n...\n</code></pre> <p>Print a list of all parameter ids, their names, and types.</p> See Also <p>Data : Aggregate object of all the parameters and their values.</p>"},{"location":"api_spcm/#bh_spc.spcm.RateValues","title":"<code>RateValues</code>","text":"<p>Rate counter values.</p> <p>Wraps the SPCM DLL <code>rate_values</code> struct. Values of this type are returned by <code>read_rates</code>.</p> <p>Attributes:</p> Name Type Description <code>sync_rate</code> <code>float</code> <p>The SYNC rate (counts/s, read-only).</p> <code>cfd_rate</code> <code>float</code> <p>The CFD rate (counts/s, read-only).</p> <code>tac_rate</code> <code>float</code> <p>The TAC rate (counts/s, read-only).</p> <code>adc_rate</code> <code>float</code> <p>The ADC rate (counts/s, read-only).</p>"},{"location":"api_spcm/#bh_spc.spcm.RateValues.as_dict","title":"<code>as_dict() -&gt; dict[str, float]</code>  <code>method descriptor</code>","text":"<p>Return a dictionary containing the fields and values.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Every field and its value.</p>"},{"location":"api_spcm/#bh_spc.spcm.RateValues.items","title":"<code>items() -&gt; Iterable[tuple[str, float]]</code>  <code>method descriptor</code>","text":"<p>Return an iterable yielding the fields and values in fixed order.</p> <p>Returns:</p> Type Description <code>Iterable</code> <p>An iterable yielding the pair (name, value) for every field.</p>"},{"location":"api_spcm/#bh_spc.spcm.SPCMError","title":"<code>SPCMError</code>","text":"<p>             Bases: <code>builtins.RuntimeError</code></p> <p>Exception raised when an SPCM function returns an error.</p> <p>Attributes:</p> Name Type Description <code>enum</code> <code>ErrorEnum</code> <p>The error enum (read-only).</p> <code>code</code> <code>int</code> <p>The raw error code, a negative value (read-only). This is usually redundant with the <code>enum</code> attribute but provided so that the code for an unknown (to pybhspc) error can be retrieved when <code>enum</code> is <code>ErrorEnum.UNKNOWN</code>.</p> See Also <p>ErrorEnum : Enum of SPCM DLL error codes.</p>"},{"location":"api_spcm/#bh_spc.spcm.StreamType","title":"<code>StreamType</code>","text":"<p>             Bases: <code>enum.Flag</code></p> <p>Flag enum for properties of SPCM DLL streams.</p> <p>Values of this type are returned by <code>get_fifo_init_vars</code> as an attribute of <code>FIFOInitVars</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for f in StreamType:\n...     print(f.name, f.value)\nHAS_SPC_HEADER 1\nHAS_MARKERS 512\nRAW_DATA 1024\nSPC_QC 2048\nBUFFERED 4096\nAUTOFREE_BUFFER 8192\nRING_BUFFER 16384\nDPC_TDC1_RAW_DATA 2\nDPC_TDC2_RAW_DATA 4\nDPC_TDC_TTL_RAW_DATA 8\nDPC 256\n</code></pre> <p>Print a table of all flag members.</p> Notes <p>pybhspc does not support the SPCM DLL stream functions.</p>"},{"location":"api_spcm/#bh_spc.spcm.SyncState","title":"<code>SyncState</code>","text":"<p>             Bases: <code>enum.Flag</code></p> <p>Flag enum for sync state.</p> <p>Values of this type are returned by <code>get_sync_state</code>.</p> <p>There are two flags: <code>SYNC_OK</code> (bit 0) and <code>SYNC_OVERLOAD</code> (bit 1). When the <code>SYNC_OVERLOAD</code> bit is set, the <code>SYNC_OK</code> bit is invalid.</p>"},{"location":"api_spcm/#bh_spc.spcm.clear_rates","title":"<code>clear_rates(mod_no: int) -&gt; None</code>  <code>method descriptor</code>","text":"<p>Initialize and clear the rate counters and start a count cycle.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required"},{"location":"api_spcm/#bh_spc.spcm.close","title":"<code>close() -&gt; None</code>  <code>method descriptor</code>","text":"<p>Uninitialize the SPCM DLL.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_actual_coltime","title":"<code>get_actual_coltime(mod_no: int) -&gt; float</code>  <code>method descriptor</code>","text":"<p>Get the remaining time to the end of the measurement, taking dead time compensation into account.</p> <p>Under some conditions (e.g., in FIFO mode with STOP_ON_TIME disabled), the return value counts up similarly to <code>get_time_from_start</code>.</p> <p><code>test_state</code> must be called periodically for this function to work correctly during measurements that exceed 80 seconds.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Remaining or elapsed collection time, in seconds.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_adjust_parameters","title":"<code>get_adjust_parameters(mod_no: int) -&gt; AdjustPara</code>  <code>method descriptor</code>","text":"<p>Get adjustment parameters of an SPC module.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>AdjustPara</code> <p>Adjustment parameters of the module.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_break_time","title":"<code>get_break_time(mod_no: int) -&gt; float</code>  <code>method descriptor</code>","text":"<p>Get the time from measurement start to stop or pause.</p> <p>The return value may not be valid in FIFO mode (to be investigated).</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Duration of measurement in seconds.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_eeprom_data","title":"<code>get_eeprom_data(mod_no: int) -&gt; EEPData</code>  <code>method descriptor</code>","text":"<p>Get EEPROM data of an SPC module.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>EEPData</code> <p>EEPROM data of the module.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_error_string","title":"<code>get_error_string(error_id: int | ErrorEnum) -&gt; str</code>  <code>method descriptor</code>","text":"<p>Return the error message for the given SPCM error code.</p> <p>Parameters:</p> Name Type Description Default <code>error_id</code> <code>int or ErrorEnum</code> <p>The error code</p> required <p>Returns:</p> Type Description <code>str</code> <p>The error message</p>"},{"location":"api_spcm/#bh_spc.spcm.get_fifo_init_vars","title":"<code>get_fifo_init_vars(mod_no: int) -&gt; FIFOInitVars</code>  <code>method descriptor</code>","text":"<p>Get format information on the currently set FIFO mode.</p> <p>The return value is only meaningful if the module is set to a FIFO mode.</p> <p>For SPC-600/630, the number of routing bits in the SPCHeader may always be zero (in both FIFO formats).</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>FIFOInitVars</code> <p>The FIFO format information.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_fifo_usage","title":"<code>get_fifo_usage(mod_no: int) -&gt; float</code>  <code>method descriptor</code>","text":"<p>Get the used fraction of the FIFO.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The fraction of the FIFO occupied (0.0 to 1.0).</p>"},{"location":"api_spcm/#bh_spc.spcm.get_init_status","title":"<code>get_init_status(mod_no: int) -&gt; InitStatus</code>  <code>method descriptor</code>","text":"<p>Get the initialization status of the given SPC module.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>InitStatus</code> <p>Whether the module is initialized, or the reason why if not.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_mode","title":"<code>get_mode() -&gt; DLLOperationMode</code>  <code>method descriptor</code>","text":"<p>Get the operation mode of the SPCM DLL.</p> <p>Returns:</p> Type Description <code>DLLOperationMode</code> <p>The mode, either hardware or simulation of a module type.</p> <p>Raises:</p> Type Description <code>SPCMError</code> <p>If there was an error (e.g., if the DLL is not initialized).</p>"},{"location":"api_spcm/#bh_spc.spcm.get_module_info","title":"<code>get_module_info(mod_no: int) -&gt; ModInfo</code>  <code>method descriptor</code>","text":"<p>Get information about an SPC module.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>ModInfo</code> <p>Basic information about the module.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_parameter","title":"<code>get_parameter(mod_no: int, par_id: ParID) -&gt; float | int</code>  <code>method descriptor</code>","text":"<p>Get one parameter's value.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <code>par_id</code> <code>ParID</code> <p>The parameter to read.</p> required <p>Returns:</p> Type Description <code>float or int</code> <p>The parameter value.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_parameters","title":"<code>get_parameters(mod_no: int) -&gt; Data</code>  <code>method descriptor</code>","text":"<p>Get all parameter values of an SPC module.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>Data</code> <p>The parameter values.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_sync_state","title":"<code>get_sync_state(mod_no: int) -&gt; SyncState</code>  <code>method descriptor</code>","text":"<p>Get the state of the SYNC input.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>SyncState</code> <p>Whether the SYNC signal is triggering and whether it is overloaded.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_time_from_start","title":"<code>get_time_from_start(mod_no: int) -&gt; float</code>  <code>method descriptor</code>","text":"<p>Get the time since measurement start.</p> <p><code>test_state</code> must be called periodically for this function to work correctly during measurements that exceed 80 seconds.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Elapsed time since measurement start, in seconds.</p>"},{"location":"api_spcm/#bh_spc.spcm.get_version","title":"<code>get_version(mod_no: int) -&gt; str</code>  <code>method descriptor</code>","text":"<p>Get the FPGA version of an SPC module.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The FPGA version (4 hex digits).</p>"},{"location":"api_spcm/#bh_spc.spcm.init","title":"<code>init(ini_file: bytes | str) -&gt; None</code>  <code>method descriptor</code>","text":"<p>Initialize the SPCM DLL and one or all of the available SPC modules.</p> <p>Parameters:</p> Name Type Description Default <code>ini_file</code> <code>bytes or str</code> <p>Filename of the .ini file used to specify parameters.</p> required <p>Raises:</p> Type Description <code>SPCMError</code> <p>If initialization fails or there were no available SPC modules.</p>"},{"location":"api_spcm/#bh_spc.spcm.measurement_state_bh_name","title":"<code>measurement_state_bh_name(name: str) -&gt; str</code>  <code>method descriptor</code>","text":"<p>Map <code>MeasurementState</code> enum member names to their SPCM DLL names.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The pybhspc <code>MeasurementState</code> enum member name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The corresponding SPCM DLL constant name.</p> See Also <p>MeasurementState</p>"},{"location":"api_spcm/#bh_spc.spcm.read_fifo","title":"<code>read_fifo(mod_no: int, data) -&gt; int</code>  <code>method descriptor</code>","text":"<p>Read data from a FIFO mode measurement.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <code>data</code> <code>array_like</code> <p>The destination buffer for the data read. The object must implement the buffer protocol, be typed unsigned short (uint16), be 1-dimentional, and be C-contiguous. For example, <code>np.empty(65536, dtype=np.uint16)</code>.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of 16-bit words read. Thus, if the return value is <code>r</code>, <code>data[:r]</code> contains valid data.</p>"},{"location":"api_spcm/#bh_spc.spcm.read_fifo_to_array","title":"<code>read_fifo_to_array(mod_no: int, max_words: int) -&gt; array.array</code>  <code>method descriptor</code>","text":"<p>Convenience wrapper around <code>read_fifo</code> that allocates an array for the output.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <code>max_words</code> <code>int</code> <p>Maximum number of 16-bit words to read.</p> required <p>Returns:</p> Type Description <code>array.array of unsigned short</code> <p>The FIFO data read. The length of the array is between 0 and <code>max_words</code>.</p>"},{"location":"api_spcm/#bh_spc.spcm.read_parameters_from_inifile","title":"<code>read_parameters_from_inifile(inifile: bytes | str) -&gt; Data</code>  <code>method descriptor</code>","text":"<p>Read an .ini file in the spcm.ini format.</p> <p>The .ini file must contain a first-line comment starting with (whitespace followed by) <code>SPCM</code>, an <code>[spc_base]</code> section, and an <code>[spc_module]</code> section. The sections may be empty but the section headers need to be terminated with a newline.</p> <p>Parameters:</p> Name Type Description Default <code>inifile</code> <code>bytes or str</code> <p>Filename of the .ini file.</p> required <p>Returns:</p> Type Description <code>Data</code> <p>The parameters read from the .ini file.</p>"},{"location":"api_spcm/#bh_spc.spcm.read_rates","title":"<code>read_rates(mod_no: int) -&gt; RateValues | None</code>  <code>method descriptor</code>","text":"<p>Read the rate counters and start a new count cycle.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>RateValues or None</code> <p>The rate counts, or None if a count cycle has not yet completed.</p>"},{"location":"api_spcm/#bh_spc.spcm.save_parameters_to_inifile","title":"<code>save_parameters_to_inifile(data: Data, dest_inifile: bytes | str, *, source_inifile: bytes | str | None = None, with_comments: bool = False) -&gt; None</code>  <code>method descriptor</code>","text":"<p>Save parameters to an .ini file in the spcm.ini format.</p> <p>A source .ini file is required for this function to work, optionally given by <code>source_inifile</code>. If not given, the filename previously passed to <code>init</code> is used. Either way, this file must exist and must contain a first-line comment starting with (whitespace followed by) <code>SPCM</code>, an <code>[spc_base]</code> section, and an <code>[spc_module]</code> section. The sections may be empty but the section headers need to be terminated with a newline.</p> <p>When <code>with_comments</code> is True, it appears that there need to be at least 2 fields set in the <code>[spc_module]</code> section of the <code>source_inifile</code>. The precise requirements have not been determined.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Data</code> <p>The parameters to save.</p> required <code>dest_inifile</code> <code>bytes or str</code> <p>Filename of the .ini file to write.</p> required <code>source_inifile</code> <code>bytes or str or None</code> <p>Filename of an .ini file from which to copy initial comment lines and the <code>[spc_base]</code> section. If None, the .ini file passed to <code>init()</code> is used.</p> <code>None</code> <code>with_comments</code> <code>bool</code> <p>If True, also copy parameter comments from <code>source_inifile</code>.</p> <code>False</code>"},{"location":"api_spcm/#bh_spc.spcm.set_mode","title":"<code>set_mode(mode: DLLOperationMode, force_use: bool, use: Sequence[bool]) -&gt; None</code>  <code>method descriptor</code>","text":"<p>Set the operation mode of the SPCM DLL and activate or deactivate each of the SPC modules.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>DLLOperationMode</code> <p>The operation mode specifying hardware or simulation module type.</p> required <code>force_use</code> <code>bool</code> <p>If true, try to obtain control of the requested modules even if they are in use by another process.</p> required <code>use</code> <code>sequence of bool</code> <p>Which SPC modules to activate. Currently up to 8 are supported. If fewer are given, the remaining modules will be deactivated.</p> required <p>Raises:</p> Type Description <code>SPCMError</code> <p>If there was an error or if no modules were activated.</p>"},{"location":"api_spcm/#bh_spc.spcm.set_parameter","title":"<code>set_parameter(mod_no: int, par_id: ParID, value: float | int) -&gt; None</code>  <code>method descriptor</code>","text":"<p>Set one parameter's value.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <code>par_id</code> <code>ParID</code> <p>The parameter to write.</p> required <code>value</code> <code>float or int</code> <p>The parameter value.</p> required"},{"location":"api_spcm/#bh_spc.spcm.set_parameters","title":"<code>set_parameters(mod_no: int, data: Data) -&gt; None</code>  <code>method descriptor</code>","text":"<p>Set all parameter values of an SPC module.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <code>data</code> <code>Data</code> <p>The parameter values.</p> required"},{"location":"api_spcm/#bh_spc.spcm.start_measurement","title":"<code>start_measurement(mod_no: int) -&gt; None</code>  <code>method descriptor</code>","text":"<p>Start a measurement.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required"},{"location":"api_spcm/#bh_spc.spcm.stop_measurement","title":"<code>stop_measurement(mod_no: int) -&gt; None</code>  <code>method descriptor</code>","text":"<p>Stop any ongoing measurement.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required"},{"location":"api_spcm/#bh_spc.spcm.test_id","title":"<code>test_id(mod_no: int) -&gt; ModuleType</code>  <code>method descriptor</code>","text":"<p>Return the module type (model number) of the given SPC module.</p> <p>The return value is not accurate if called before <code>init</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>ModuleType</code> <p>The module type enum.</p>"},{"location":"api_spcm/#bh_spc.spcm.test_state","title":"<code>test_state(mod_no: int) -&gt; MeasurementState</code>  <code>method descriptor</code>","text":"<p>Get various status flags for the last-started measurement.</p> <p>This function should be called periodically during a measurement in order to detect when the measurement is stopped (among other things).</p> <p>Parameters:</p> Name Type Description Default <code>mod_no</code> <code>int</code> <p>The SPC module index.</p> required <p>Returns:</p> Type Description <code>MeasurementState</code> <p>Flags indicating timer and FIFO states, reason for measurement stop, etc.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#developing-pybhspc","title":"Developing pybhspc","text":""},{"location":"development/#code-overview","title":"Code overview","text":"<p>pybhspc uses Cython to generate Python bindings for the SPCM DLL functions and structs (<code>_spcm.pxd</code>, <code>spcm.pyx</code>). Enum constants are defined using the Python standard library <code>enum</code> package. A few Win32 API functions are also separately wrapped (<code>_win32_version.pxd</code>, <code>_file_version.pyx</code>) to detect the DLL version information.</p> <p>Loading the extension module <code>spcm</code> requires that the SPCM DLL be accessible. This is set up in the <code>__init__.py</code> of the <code>bh_spc</code> package.</p> <p>The build uses setuptools and is configured in <code>pyproject.toml</code> (and <code>setup.py</code> for building the extension modules).</p> <p>Tests are run using pytest, with the <code>spcm</code> extension module also using doctest (called by one of the pytest test cases).</p> <p>Documentation is built with MkDocs, with mkdocstrings used to include the docstrings for the API Reference. This requires a versions of the extension modules, because the docstrings for those are extracted from the imported modules. Usage examples use the mkdocs-jupyter plugin and are in jupytext format; they are executed as part of the documentation build.</p> <p>Nox is used to standardize and automate the \"official\" build and testing process (across all the supported versions of Python).</p> <p>A pre-commit hook is used to run linting, formatting, and type checking by mypy.</p> <p>At the moment mypy is unable to access the type annotations in the extension modules. Fixing this will require generating type stubs (<code>.pyi</code>) from the Cython source (<code>.pyx</code>) and/or the built extension modules; there does not appear to be a stable, ready-made, and fully automated way to do this.</p>"},{"location":"development/#building-and-testing","title":"Building and testing","text":""},{"location":"development/#requirements","title":"Requirements","text":"<p>Windows 10+, 64-bit Intel.</p> <p>Visual Studio 2017+ (latest version recommended) with <code>C++ Desktop Development</code> workload. Alternatively, Build Tools for Visual Studio (2017+) should also work, but this has not been tested.</p> <p>Python 3.10+.</p> <p>Becker &amp; Hickl TCSPC Package with SPCM DLL 5.2.0 (Sep 2023, TCSPC Package 7.0) or later (note that a more recent version is required than at run time). SPCM DLL 5.1.0 (Dec 2022) is the theoretical minimum requirement, but its header file <code>Spcm_def.h</code> may need to have trailing whitespace removed to compile.</p>"},{"location":"development/#pre-commit-hook","title":"Pre-commit hook","text":"<p>Activate the pre-commit hook with <code>pre-commit install</code>.</p>"},{"location":"development/#building-for-iterative-development","title":"Building for iterative development","text":"<p>Run this once:</p> <pre><code>python -m venv venv                    # Create virtual environment 'venv'.\necho '*' &gt;venv/.gitignore              # Git should ignore 'venv'.\npip install .[dev]\npip install --no-build-isolation -e .  # Editable install.\n</code></pre> <p>(<code>--no-build-isolation</code> allows for faster builds but requires build requirements to be pre-installed.)</p> <p>Then, to iterate on the code and documentation run these commands as needed:</p> <pre><code>python setup.py build_ext --inplace    # Must run if .pyx files changed.\npytest                                 # Run the tests.\nmkdocs serve                           # Build and serve the docs.\n</code></pre> <p>(You could rerun the editable install instead of invoking <code>setup.py</code> to rebuild the extension modules, but that takes longer.)</p>"},{"location":"development/#testing-in-isolated-environments","title":"Testing in isolated environments","text":"<pre><code>pip install nox    # Also included in 'pip install .[dev]'.\nnox                # Build and run the tests.\n</code></pre> <p>By default this attempts to test with every supported Python version (if available).</p>"},{"location":"development/#building-wheels","title":"Building wheels","text":"<pre><code>nox -s build\n</code></pre> <p>By default this attempts to build wheels for every supported Python version (if available).</p>"},{"location":"development/#building-the-documentation","title":"Building the documentation","text":"<pre><code>nox -s docs\n</code></pre> <p>Note that this builds the extension modules and the documentation in-tree. The built documentation is in <code>site/</code>.</p>"},{"location":"development/#contributing-to-pybhspc","title":"Contributing to pybhspc","text":"<p>pybhspc is an open source project and contributions are welcome. Please create a GitHub issue or pull request.</p> <p>If you plan to propose a significant change, it is a good idea to first create an issue to discuss the design and scope of the change.</p> <p>New code should be accompanied with unit tests where practical (but this should focus on testing pybhspc, not the behavior of the SPCM DLL). Also, new or changed APIs should be documented. Generally, please follow the existing style and structure of code and documentation when there is no reason not to.</p>"},{"location":"getting_started/","title":"Getting Started","text":"In\u00a0[1]: Copied! <pre>import bh_spc\nfrom bh_spc import spcm\n\nimport time\nimport matplotlib.pyplot as plt\nimport numpy as np\n</pre> import bh_spc from bh_spc import spcm  import time import matplotlib.pyplot as plt import numpy as np <p>The first step in using the SPCM functions is to initialize the library. This initializes both the library itself and the available devices. Initialization requires an <code>.ini</code> file containing mode selection (hardware or simulator) and acquisition parameters.</p> <p>In a real acquisition, you might want to load an <code>.ini</code> file with the desired parameters (possibly one saved in the SPCM application). Here we will use pybhspc's utility functions to provide a temporary <code>.ini</code> file that does nothing but select the DLL operation mode (in this case simulation of SPC-180NX):</p> In\u00a0[2]: Copied! <pre>with bh_spc.ini_file(\n    bh_spc.minimal_spcm_ini(spcm.DLLOperationMode.SIMULATE_SPC_180NX)\n) as ini:\n    spcm.init(ini)\n</pre> with bh_spc.ini_file(     bh_spc.minimal_spcm_ini(spcm.DLLOperationMode.SIMULATE_SPC_180NX) ) as ini:     spcm.init(ini) <p>To run this code with a real device, you would replace <code>SIMULATE_SPC_180NX</code> with <code>HARDWARE</code>.</p> <p>The SPCM DLL distinguishes multiple installed SPC boards (\"modules\") using a module number ranging from 0 to 31. In simulation mode, all of these numbers are valid. In hardware mode, if you have a single SPC board, it should be module number 0. Since we will be specifying this many times, let's define a variable:</p> In\u00a0[3]: Copied! <pre>mod_no = 0\n</pre> mod_no = 0 <p>It is a good idea to confirm that initialization of the module was successful. The following will also give the reason for failure if initialization was unsuccessful:</p> In\u00a0[4]: Copied! <pre>spcm.get_init_status(mod_no)\n</pre> spcm.get_init_status(mod_no) Out[4]: <pre>&lt;InitStatus.OK: 0&gt;</pre> In\u00a0[5]: Copied! <pre>spcm.set_parameter(mod_no, spcm.ParID.MODE, 1)\n</pre> spcm.set_parameter(mod_no, spcm.ParID.MODE, 1) <p>Let's take a look at all the parameters:</p> In\u00a0[6]: Copied! <pre>params = spcm.get_parameters(mod_no)\n\nfor par, val in params.items():\n    print(f\"{par} = {val}\")\n</pre> params = spcm.get_parameters(mod_no)  for par, val in params.items():     print(f\"{par} = {val}\") <pre>cfd_limit_low = -0.0\ncfd_limit_high = 80.0\ncfd_zc_level = 0.0\ncfd_holdoff = 5.0\nsync_zc_level = 0.0\nsync_freq_div = 4\nsync_holdoff = 4.0\nsync_threshold = -19.60784339904785\ntac_range = 50.033573150634766\ntac_gain = 1\ntac_offset = 0.0\ntac_limit_low = 10.196078300476074\ntac_limit_high = 80.0\nadc_resolution = 12\next_latch_delay = 0\ncollect_time = 0.009999999776482582\ndisplay_time = 1.0\nrepeat_time = 10.0\nstop_on_time = 1\nstop_on_ovfl = 1\ndither_range = 0\ncount_incr = 1\nmem_bank = 0\ndead_time_comp = 0\nscan_control = 0\nrouting_mode = 0\ntac_enable_hold = 0.0\nmode = 1\nscan_size_x = 1\nscan_size_y = 1\nscan_rout_x = 1\nscan_rout_y = 1\nscan_polarity = 0\nscan_flyback = 65537\nscan_borders = 0\npixel_time = 2.0000000233721948e-07\npixel_clock = 0\nline_compression = 1\ntrigger = 0\next_pixclk_div = 1\nrate_count_time = 1.0\nmacro_time_clk = 0\nadd_select = 0\nadc_zoom = 0\nxy_gain = 1\nimg_size_x = 1\nimg_size_y = 1\nimg_rout_x = 1\nimg_rout_y = 1\nmaster_clock = 2\nadc_sample_delay = 0\ndetector_type = 1\ntdc_control = 0\nchan_enable = 4191231\nchan_slope = 0\nchan_spec_no = 34835\ntdc_offset1 = 0.0\ntdc_offset2 = 0.0\ntdc_offset3 = 0.0\ntdc_offset4 = 0.0\n</pre> <p>Note that not all of these parameters have meaning in every SPC model, and many don't apply at all to FIFO mode.</p> <p>In an actual FIFO acquisition with hardware, you will almost certainly need to adjust some or all of these: <code>cfd_*</code>, <code>sync_*</code>, <code>tac_*</code>, <code>ext_latch_delay</code>, <code>collect_time</code>, <code>stop_on_time</code>, <code>dither_range</code>, <code>routing_mode</code>, <code>trigger</code>, and <code>macro_time_clk</code>. See the BH documentation and TCSPC Handbook for details.</p> In\u00a0[7]: Copied! <pre># For this demonstration, we will turn off `stop_on_time`, mostly because it\n# does not appear to work in simulation mode. By turning it off, running this\n# example on real hardware should behave the same way.\nparams.stop_on_time = 0\n\n# (Set other parameters here!)\n\nspcm.set_parameters(mod_no, params)\n</pre> # For this demonstration, we will turn off `stop_on_time`, mostly because it # does not appear to work in simulation mode. By turning it off, running this # example on real hardware should behave the same way. params.stop_on_time = 0  # (Set other parameters here!)  spcm.set_parameters(mod_no, params) <p>It is also a good idea to read out all the parameters after making changes, because some parameters will be snapped to allowed values. We'll skip that here for brevity.</p> In\u00a0[8]: Copied! <pre>duration = 0.1  # s\nbuf_size = 32768  # Max number of 16-bit words in a single read.\n\nspcm.start_measurement(mod_no)\nstart_time = time.monotonic()\n\ndata = []  # Collect arrays of data into a list.\nwhile True:\n    elapsed = time.monotonic() - start_time\n    if elapsed &gt;= duration:\n        spcm.stop_measurement(mod_no)\n        break\n    buf = spcm.read_fifo_to_array(mod_no, buf_size)\n    if len(buf):\n        data.append(buf)\n    if len(buf) &lt; buf_size:  # We've read all there is to read.\n        time.sleep(0.001)\n\n# Make sure to read the data that arrived after stopping (if you need it).\nwhile True:\n    buf = spcm.read_fifo_to_array(mod_no, buf_size)\n    if not len(buf):\n        break\n    data.append(buf)\n</pre> duration = 0.1  # s buf_size = 32768  # Max number of 16-bit words in a single read.  spcm.start_measurement(mod_no) start_time = time.monotonic()  data = []  # Collect arrays of data into a list. while True:     elapsed = time.monotonic() - start_time     if elapsed &gt;= duration:         spcm.stop_measurement(mod_no)         break     buf = spcm.read_fifo_to_array(mod_no, buf_size)     if len(buf):         data.append(buf)     if len(buf) &lt; buf_size:  # We've read all there is to read.         time.sleep(0.001)  # Make sure to read the data that arrived after stopping (if you need it). while True:     buf = spcm.read_fifo_to_array(mod_no, buf_size)     if not len(buf):         break     data.append(buf) <p><code>read_fifo_to_array()</code> returns an <code>array.array</code> of unsigned 16-bit numbers, but the event records are 32-bit. Numpy can be used to concatenate all the acquired data into a single array of 32-bit records:</p> In\u00a0[9]: Copied! <pre>records = np.concatenate(data).view(np.uint32)\nlen(records)\n</pre> records = np.concatenate(data).view(np.uint32) len(records) Out[9]: <pre>1310819</pre> <p>It is beyond pybhspc's job to interpret the event records. However, let's do a few simple things.</p> <p>Bit 29 (with bit 0 being the least significant bit) is the GAP bit, which indicates there was a FIFO overflow. Let's make sure no overflow occurred:</p> In\u00a0[10]: Copied! <pre>had_gap = np.any(np.bitwise_and(records, 1 &lt;&lt; 29))\nprint(\"There was {} gap\".format(\"a\" if had_gap else \"no\"))\n</pre> had_gap = np.any(np.bitwise_and(records, 1 &lt;&lt; 29)) print(\"There was {} gap\".format(\"a\" if had_gap else \"no\")) <pre>There was no gap\n</pre> <p>Photon records have bits 31 and 28 cleared. Let's count the photons:</p> In\u00a0[11]: Copied! <pre>photons = np.extract(np.bitwise_and(records, 0b1001 &lt;&lt; 28) == 0, records)\nlen(photons)\n</pre> photons = np.extract(np.bitwise_and(records, 0b1001 &lt;&lt; 28) == 0, records) len(photons) Out[11]: <pre>1310720</pre> <p>And just for fun, we can plot a histogram of the photon microtimes, which are the lower 12 bits of the higher 16 bits of the records (admittedly this is not all that interesting with the simulated data):</p> In\u00a0[12]: Copied! <pre>max_12bit = (1 &lt;&lt; 12) - 1  # 4095\nmicrotimes = np.bitwise_and(np.right_shift(photons, 16), max_12bit)\n\n# Reverse the macrotimes by subtracting from the max value, because microtime\n# is measured from photon to SYNC, not SYNC to photon.\nmicrotimes = max_12bit - microtimes\n\nh = plt.hist(microtimes, bins=64)\n</pre> max_12bit = (1 &lt;&lt; 12) - 1  # 4095 microtimes = np.bitwise_and(np.right_shift(photons, 16), max_12bit)  # Reverse the macrotimes by subtracting from the max value, because microtime # is measured from photon to SYNC, not SYNC to photon. microtimes = max_12bit - microtimes  h = plt.hist(microtimes, bins=64)"},{"location":"getting_started/#getting-started","title":"Getting Started\u00b6","text":"<p>At the moment pybhspc only provides low-level bindings to the SPCM DLL functions. Using these requires familiarizing yourself with the SPCM DLL documentation.</p> <p>Here we demonstrate a basic FIFO (time tag stream) mode acquisition.</p>"},{"location":"getting_started/#setting-up","title":"Setting Up\u00b6","text":"<p>First, let's import the package, and the module <code>spcm</code> (as well as a few others that we will use below):</p>"},{"location":"getting_started/#getting-and-setting-parameters","title":"Getting and Setting Parameters\u00b6","text":"<p>Now let's set the SPC module's mode to FIFO mode. For most non-ancient SPC boards, FIFO mode is mode 1 (different numbers are required for SPC-600, 630, and 130 (but not 130EM/IN)):</p>"},{"location":"getting_started/#acquiring-data","title":"Acquiring Data\u00b6","text":"<p>Now let's acquire some data. In FIFO mode, it is necessary to frequently read out the available data during an acquisition (\"measurement\") so that the FIFO (first-in first-out) buffer of the device does not overflow (FIFO overflow can be detected, but that is not covered here).</p> <p>In this simple example, let's just run the acquisition for a short, fixed time (the duration is software-controlled here, so it won't be precise):</p>"}]}